// Code generated by Thrift Compiler (0.16.0). DO NOT EDIT.

package encryption

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// Attributes:
//  - Key
type VerificationKeyThrift struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
}

func NewVerificationKeyThrift() *VerificationKeyThrift {
  return &VerificationKeyThrift{}
}


func (p *VerificationKeyThrift) GetKey() []byte {
  return p.Key
}
func (p *VerificationKeyThrift) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetKey = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  return nil
}

func (p *VerificationKeyThrift)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *VerificationKeyThrift) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "VerificationKeyThrift"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *VerificationKeyThrift) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *VerificationKeyThrift) Equals(other *VerificationKeyThrift) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Key, other.Key) != 0 { return false }
  return true
}

func (p *VerificationKeyThrift) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("VerificationKeyThrift(%+v)", *p)
}

// Attributes:
//  - Key
type PrivateKeyThrift struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
}

func NewPrivateKeyThrift() *PrivateKeyThrift {
  return &PrivateKeyThrift{}
}


func (p *PrivateKeyThrift) GetKey() []byte {
  return p.Key
}
func (p *PrivateKeyThrift) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetKey = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  return nil
}

func (p *PrivateKeyThrift)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *PrivateKeyThrift) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PrivateKeyThrift"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PrivateKeyThrift) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *PrivateKeyThrift) Equals(other *PrivateKeyThrift) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Key, other.Key) != 0 { return false }
  return true
}

func (p *PrivateKeyThrift) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PrivateKeyThrift(%+v)", *p)
}

// Attributes:
//  - U
//  - V
//  - W
type EncryptedMessageThrift struct {
  U []byte `thrift:"U,1,required" db:"U" json:"U"`
  V []byte `thrift:"V,2,required" db:"V" json:"V"`
  W []byte `thrift:"W,3,required" db:"W" json:"W"`
}

func NewEncryptedMessageThrift() *EncryptedMessageThrift {
  return &EncryptedMessageThrift{}
}


func (p *EncryptedMessageThrift) GetU() []byte {
  return p.U
}

func (p *EncryptedMessageThrift) GetV() []byte {
  return p.V
}

func (p *EncryptedMessageThrift) GetW() []byte {
  return p.W
}
func (p *EncryptedMessageThrift) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetU bool = false;
  var issetV bool = false;
  var issetW bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetU = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetV = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetW = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetU{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field U is not set"));
  }
  if !issetV{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field V is not set"));
  }
  if !issetW{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field W is not set"));
  }
  return nil
}

func (p *EncryptedMessageThrift)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.U = v
}
  return nil
}

func (p *EncryptedMessageThrift)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *EncryptedMessageThrift)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.W = v
}
  return nil
}

func (p *EncryptedMessageThrift) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "EncryptedMessageThrift"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EncryptedMessageThrift) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "U", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:U: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.U); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.U (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:U: ", p), err) }
  return err
}

func (p *EncryptedMessageThrift) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "V", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:V: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.V (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:V: ", p), err) }
  return err
}

func (p *EncryptedMessageThrift) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "W", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:W: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.W); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.W (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:W: ", p), err) }
  return err
}

func (p *EncryptedMessageThrift) Equals(other *EncryptedMessageThrift) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.U, other.U) != 0 { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  if bytes.Compare(p.W, other.W) != 0 { return false }
  return true
}

func (p *EncryptedMessageThrift) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EncryptedMessageThrift(%+v)", *p)
}

// Attributes:
//  - L
//  - K
//  - VK
//  - VKs
type TPKEPublicKeyThrift struct {
  L int32 `thrift:"l,1,required" db:"l" json:"l"`
  K int32 `thrift:"k,2,required" db:"k" json:"k"`
  VK *VerificationKeyThrift `thrift:"VK,3,required" db:"VK" json:"VK"`
  VKs []*VerificationKeyThrift `thrift:"VKs,4,required" db:"VKs" json:"VKs"`
}

func NewTPKEPublicKeyThrift() *TPKEPublicKeyThrift {
  return &TPKEPublicKeyThrift{}
}


func (p *TPKEPublicKeyThrift) GetL() int32 {
  return p.L
}

func (p *TPKEPublicKeyThrift) GetK() int32 {
  return p.K
}
var TPKEPublicKeyThrift_VK_DEFAULT *VerificationKeyThrift
func (p *TPKEPublicKeyThrift) GetVK() *VerificationKeyThrift {
  if !p.IsSetVK() {
    return TPKEPublicKeyThrift_VK_DEFAULT
  }
return p.VK
}

func (p *TPKEPublicKeyThrift) GetVKs() []*VerificationKeyThrift {
  return p.VKs
}
func (p *TPKEPublicKeyThrift) IsSetVK() bool {
  return p.VK != nil
}

func (p *TPKEPublicKeyThrift) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetL bool = false;
  var issetK bool = false;
  var issetVK bool = false;
  var issetVKs bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetL = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetK = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetVK = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetVKs = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetL{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field L is not set"));
  }
  if !issetK{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field K is not set"));
  }
  if !issetVK{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field VK is not set"));
  }
  if !issetVKs{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field VKs is not set"));
  }
  return nil
}

func (p *TPKEPublicKeyThrift)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.L = v
}
  return nil
}

func (p *TPKEPublicKeyThrift)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.K = v
}
  return nil
}

func (p *TPKEPublicKeyThrift)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.VK = &VerificationKeyThrift{}
  if err := p.VK.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VK), err)
  }
  return nil
}

func (p *TPKEPublicKeyThrift)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*VerificationKeyThrift, 0, size)
  p.VKs =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &VerificationKeyThrift{}
    if err := _elem0.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.VKs = append(p.VKs, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TPKEPublicKeyThrift) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TPKEPublicKeyThrift"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEPublicKeyThrift) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "l", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:l: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.L)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.l (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:l: ", p), err) }
  return err
}

func (p *TPKEPublicKeyThrift) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.K)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.k (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *TPKEPublicKeyThrift) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "VK", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:VK: ", p), err) }
  if err := p.VK.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VK), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:VK: ", p), err) }
  return err
}

func (p *TPKEPublicKeyThrift) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "VKs", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:VKs: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.VKs)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.VKs {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:VKs: ", p), err) }
  return err
}

func (p *TPKEPublicKeyThrift) Equals(other *TPKEPublicKeyThrift) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.L != other.L { return false }
  if p.K != other.K { return false }
  if !p.VK.Equals(other.VK) { return false }
  if len(p.VKs) != len(other.VKs) { return false }
  for i, _tgt := range p.VKs {
    _src1 := other.VKs[i]
    if !_tgt.Equals(_src1) { return false }
  }
  return true
}

func (p *TPKEPublicKeyThrift) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEPublicKeyThrift(%+v)", *p)
}

// Attributes:
//  - PubKey
//  - SK
//  - I
type TPKEPrivateKeyThrift struct {
  PubKey *TPKEPublicKeyThrift `thrift:"PubKey,1,required" db:"PubKey" json:"PubKey"`
  SK *PrivateKeyThrift `thrift:"SK,2,required" db:"SK" json:"SK"`
  I int32 `thrift:"i,3,required" db:"i" json:"i"`
}

func NewTPKEPrivateKeyThrift() *TPKEPrivateKeyThrift {
  return &TPKEPrivateKeyThrift{}
}

var TPKEPrivateKeyThrift_PubKey_DEFAULT *TPKEPublicKeyThrift
func (p *TPKEPrivateKeyThrift) GetPubKey() *TPKEPublicKeyThrift {
  if !p.IsSetPubKey() {
    return TPKEPrivateKeyThrift_PubKey_DEFAULT
  }
return p.PubKey
}
var TPKEPrivateKeyThrift_SK_DEFAULT *PrivateKeyThrift
func (p *TPKEPrivateKeyThrift) GetSK() *PrivateKeyThrift {
  if !p.IsSetSK() {
    return TPKEPrivateKeyThrift_SK_DEFAULT
  }
return p.SK
}

func (p *TPKEPrivateKeyThrift) GetI() int32 {
  return p.I
}
func (p *TPKEPrivateKeyThrift) IsSetPubKey() bool {
  return p.PubKey != nil
}

func (p *TPKEPrivateKeyThrift) IsSetSK() bool {
  return p.SK != nil
}

func (p *TPKEPrivateKeyThrift) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetPubKey bool = false;
  var issetSK bool = false;
  var issetI bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetPubKey = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetSK = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetI = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetPubKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field PubKey is not set"));
  }
  if !issetSK{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SK is not set"));
  }
  if !issetI{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field I is not set"));
  }
  return nil
}

func (p *TPKEPrivateKeyThrift)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PubKey = &TPKEPublicKeyThrift{}
  if err := p.PubKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PubKey), err)
  }
  return nil
}

func (p *TPKEPrivateKeyThrift)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SK = &PrivateKeyThrift{}
  if err := p.SK.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SK), err)
  }
  return nil
}

func (p *TPKEPrivateKeyThrift)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.I = v
}
  return nil
}

func (p *TPKEPrivateKeyThrift) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TPKEPrivateKeyThrift"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEPrivateKeyThrift) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PubKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:PubKey: ", p), err) }
  if err := p.PubKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PubKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:PubKey: ", p), err) }
  return err
}

func (p *TPKEPrivateKeyThrift) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "SK", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:SK: ", p), err) }
  if err := p.SK.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SK), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:SK: ", p), err) }
  return err
}

func (p *TPKEPrivateKeyThrift) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "i", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:i: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.I)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.i (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:i: ", p), err) }
  return err
}

func (p *TPKEPrivateKeyThrift) Equals(other *TPKEPrivateKeyThrift) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.PubKey.Equals(other.PubKey) { return false }
  if !p.SK.Equals(other.SK) { return false }
  if p.I != other.I { return false }
  return true
}

func (p *TPKEPrivateKeyThrift) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEPrivateKeyThrift(%+v)", *p)
}

// Attributes:
//  - PubKey
//  - PrivKeys
type DealerThrift struct {
  PubKey *TPKEPublicKeyThrift `thrift:"PubKey,1,required" db:"PubKey" json:"PubKey"`
  PrivKeys []*TPKEPrivateKeyThrift `thrift:"PrivKeys,2,required" db:"PrivKeys" json:"PrivKeys"`
}

func NewDealerThrift() *DealerThrift {
  return &DealerThrift{}
}

var DealerThrift_PubKey_DEFAULT *TPKEPublicKeyThrift
func (p *DealerThrift) GetPubKey() *TPKEPublicKeyThrift {
  if !p.IsSetPubKey() {
    return DealerThrift_PubKey_DEFAULT
  }
return p.PubKey
}

func (p *DealerThrift) GetPrivKeys() []*TPKEPrivateKeyThrift {
  return p.PrivKeys
}
func (p *DealerThrift) IsSetPubKey() bool {
  return p.PubKey != nil
}

func (p *DealerThrift) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetPubKey bool = false;
  var issetPrivKeys bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetPubKey = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetPrivKeys = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetPubKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field PubKey is not set"));
  }
  if !issetPrivKeys{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field PrivKeys is not set"));
  }
  return nil
}

func (p *DealerThrift)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PubKey = &TPKEPublicKeyThrift{}
  if err := p.PubKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PubKey), err)
  }
  return nil
}

func (p *DealerThrift)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TPKEPrivateKeyThrift, 0, size)
  p.PrivKeys =  tSlice
  for i := 0; i < size; i ++ {
    _elem2 := &TPKEPrivateKeyThrift{}
    if err := _elem2.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
    }
    p.PrivKeys = append(p.PrivKeys, _elem2)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *DealerThrift) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DealerThrift"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DealerThrift) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PubKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:PubKey: ", p), err) }
  if err := p.PubKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PubKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:PubKey: ", p), err) }
  return err
}

func (p *DealerThrift) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PrivKeys", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:PrivKeys: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.PrivKeys)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.PrivKeys {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:PrivKeys: ", p), err) }
  return err
}

func (p *DealerThrift) Equals(other *DealerThrift) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.PubKey.Equals(other.PubKey) { return false }
  if len(p.PrivKeys) != len(other.PrivKeys) { return false }
  for i, _tgt := range p.PrivKeys {
    _src3 := other.PrivKeys[i]
    if !_tgt.Equals(_src3) { return false }
  }
  return true
}

func (p *DealerThrift) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DealerThrift(%+v)", *p)
}

// Attributes:
//  - Key
type AESKey struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
}

func NewAESKey() *AESKey {
  return &AESKey{}
}


func (p *AESKey) GetKey() []byte {
  return p.Key
}
func (p *AESKey) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetKey = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  return nil
}

func (p *AESKey)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *AESKey) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AESKey"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AESKey) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *AESKey) Equals(other *AESKey) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Key, other.Key) != 0 { return false }
  return true
}

func (p *AESKey) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AESKey(%+v)", *p)
}

type TPKEService interface {
  // Parameters:
  //  - PubKey
  //  - S
  //  - J
  Lagrange(ctx context.Context, PubKey *TPKEPublicKeyThrift, S []int32, j int32) (_r int32, _err error)
  // Parameters:
  //  - PubKey
  //  - M
  Encrypt(ctx context.Context, PubKey *TPKEPublicKeyThrift, m string) (_r *EncryptedMessageThrift, _err error)
  // Parameters:
  //  - PubKey
  //  - Em
  //  - Shares
  CombineShares(ctx context.Context, PubKey *TPKEPublicKeyThrift, em *EncryptedMessageThrift, shares map[int32][]byte) (_r []byte, _err error)
  // Parameters:
  //  - PrivKey
  //  - Em
  DecryptShare(ctx context.Context, PrivKey *TPKEPrivateKeyThrift, em *EncryptedMessageThrift) (_r []byte, _err error)
  // Parameters:
  //  - Players
  //  - K
  Dealer(ctx context.Context, players int32, k int32) (_r *DealerThrift, _err error)
  // Parameters:
  //  - Key
  //  - Raw
  AesEncrypt(ctx context.Context, key *AESKey, raw []byte) (_r []byte, _err error)
  // Parameters:
  //  - Key
  //  - EncMes
  AesDecrypt(ctx context.Context, key *AESKey, encMes []byte) (_r []byte, _err error)
}

type TPKEServiceClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewTPKEServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *TPKEServiceClient {
  return &TPKEServiceClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewTPKEServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *TPKEServiceClient {
  return &TPKEServiceClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewTPKEServiceClient(c thrift.TClient) *TPKEServiceClient {
  return &TPKEServiceClient{
    c: c,
  }
}

func (p *TPKEServiceClient) Client_() thrift.TClient {
  return p.c
}

func (p *TPKEServiceClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *TPKEServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - PubKey
//  - S
//  - J
func (p *TPKEServiceClient) Lagrange(ctx context.Context, PubKey *TPKEPublicKeyThrift, S []int32, j int32) (_r int32, _err error) {
  var _args4 TPKEServiceLagrangeArgs
  _args4.PubKey = PubKey
  _args4.S = S
  _args4.J = j
  var _result6 TPKEServiceLagrangeResult
  var _meta5 thrift.ResponseMeta
  _meta5, _err = p.Client_().Call(ctx, "lagrange", &_args4, &_result6)
  p.SetLastResponseMeta_(_meta5)
  if _err != nil {
    return
  }
  return _result6.GetSuccess(), nil
}

// Parameters:
//  - PubKey
//  - M
func (p *TPKEServiceClient) Encrypt(ctx context.Context, PubKey *TPKEPublicKeyThrift, m string) (_r *EncryptedMessageThrift, _err error) {
  var _args7 TPKEServiceEncryptArgs
  _args7.PubKey = PubKey
  _args7.M = m
  var _result9 TPKEServiceEncryptResult
  var _meta8 thrift.ResponseMeta
  _meta8, _err = p.Client_().Call(ctx, "encrypt", &_args7, &_result9)
  p.SetLastResponseMeta_(_meta8)
  if _err != nil {
    return
  }
  if _ret10 := _result9.GetSuccess(); _ret10 != nil {
    return _ret10, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "encrypt failed: unknown result")
}

// Parameters:
//  - PubKey
//  - Em
//  - Shares
func (p *TPKEServiceClient) CombineShares(ctx context.Context, PubKey *TPKEPublicKeyThrift, em *EncryptedMessageThrift, shares map[int32][]byte) (_r []byte, _err error) {
  var _args11 TPKEServiceCombineSharesArgs
  _args11.PubKey = PubKey
  _args11.Em = em
  _args11.Shares = shares
  var _result13 TPKEServiceCombineSharesResult
  var _meta12 thrift.ResponseMeta
  _meta12, _err = p.Client_().Call(ctx, "combineShares", &_args11, &_result13)
  p.SetLastResponseMeta_(_meta12)
  if _err != nil {
    return
  }
  return _result13.GetSuccess(), nil
}

// Parameters:
//  - PrivKey
//  - Em
func (p *TPKEServiceClient) DecryptShare(ctx context.Context, PrivKey *TPKEPrivateKeyThrift, em *EncryptedMessageThrift) (_r []byte, _err error) {
  var _args14 TPKEServiceDecryptShareArgs
  _args14.PrivKey = PrivKey
  _args14.Em = em
  var _result16 TPKEServiceDecryptShareResult
  var _meta15 thrift.ResponseMeta
  _meta15, _err = p.Client_().Call(ctx, "decryptShare", &_args14, &_result16)
  p.SetLastResponseMeta_(_meta15)
  if _err != nil {
    return
  }
  return _result16.GetSuccess(), nil
}

// Parameters:
//  - Players
//  - K
func (p *TPKEServiceClient) Dealer(ctx context.Context, players int32, k int32) (_r *DealerThrift, _err error) {
  var _args17 TPKEServiceDealerArgs
  _args17.Players = players
  _args17.K = k
  var _result19 TPKEServiceDealerResult
  var _meta18 thrift.ResponseMeta
  _meta18, _err = p.Client_().Call(ctx, "dealer", &_args17, &_result19)
  p.SetLastResponseMeta_(_meta18)
  if _err != nil {
    return
  }
  if _ret20 := _result19.GetSuccess(); _ret20 != nil {
    return _ret20, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "dealer failed: unknown result")
}

// Parameters:
//  - Key
//  - Raw
func (p *TPKEServiceClient) AesEncrypt(ctx context.Context, key *AESKey, raw []byte) (_r []byte, _err error) {
  var _args21 TPKEServiceAesEncryptArgs
  _args21.Key = key
  _args21.Raw = raw
  var _result23 TPKEServiceAesEncryptResult
  var _meta22 thrift.ResponseMeta
  _meta22, _err = p.Client_().Call(ctx, "aesEncrypt", &_args21, &_result23)
  p.SetLastResponseMeta_(_meta22)
  if _err != nil {
    return
  }
  return _result23.GetSuccess(), nil
}

// Parameters:
//  - Key
//  - EncMes
func (p *TPKEServiceClient) AesDecrypt(ctx context.Context, key *AESKey, encMes []byte) (_r []byte, _err error) {
  var _args24 TPKEServiceAesDecryptArgs
  _args24.Key = key
  _args24.EncMes = encMes
  var _result26 TPKEServiceAesDecryptResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "aesDecrypt", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  return _result26.GetSuccess(), nil
}

type TPKEServiceProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler TPKEService
}

func (p *TPKEServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *TPKEServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *TPKEServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewTPKEServiceProcessor(handler TPKEService) *TPKEServiceProcessor {

  self27 := &TPKEServiceProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self27.processorMap["lagrange"] = &tPKEServiceProcessorLagrange{handler:handler}
  self27.processorMap["encrypt"] = &tPKEServiceProcessorEncrypt{handler:handler}
  self27.processorMap["combineShares"] = &tPKEServiceProcessorCombineShares{handler:handler}
  self27.processorMap["decryptShare"] = &tPKEServiceProcessorDecryptShare{handler:handler}
  self27.processorMap["dealer"] = &tPKEServiceProcessorDealer{handler:handler}
  self27.processorMap["aesEncrypt"] = &tPKEServiceProcessorAesEncrypt{handler:handler}
  self27.processorMap["aesDecrypt"] = &tPKEServiceProcessorAesDecrypt{handler:handler}
return self27
}

func (p *TPKEServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x28 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x28.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x28

}

type tPKEServiceProcessorLagrange struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorLagrange) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceLagrangeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "lagrange", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceLagrangeResult{}
  var retval int32
  if retval, err2 = p.handler.Lagrange(ctx, args.PubKey, args.S, args.J); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing lagrange: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "lagrange", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "lagrange", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type tPKEServiceProcessorEncrypt struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorEncrypt) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceEncryptArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "encrypt", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceEncryptResult{}
  var retval *EncryptedMessageThrift
  if retval, err2 = p.handler.Encrypt(ctx, args.PubKey, args.M); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing encrypt: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "encrypt", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "encrypt", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type tPKEServiceProcessorCombineShares struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorCombineShares) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceCombineSharesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "combineShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceCombineSharesResult{}
  var retval []byte
  if retval, err2 = p.handler.CombineShares(ctx, args.PubKey, args.Em, args.Shares); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing combineShares: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "combineShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "combineShares", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type tPKEServiceProcessorDecryptShare struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorDecryptShare) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceDecryptShareArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "decryptShare", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceDecryptShareResult{}
  var retval []byte
  if retval, err2 = p.handler.DecryptShare(ctx, args.PrivKey, args.Em); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing decryptShare: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "decryptShare", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "decryptShare", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type tPKEServiceProcessorDealer struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorDealer) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceDealerArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "dealer", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceDealerResult{}
  var retval *DealerThrift
  if retval, err2 = p.handler.Dealer(ctx, args.Players, args.K); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing dealer: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "dealer", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "dealer", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type tPKEServiceProcessorAesEncrypt struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorAesEncrypt) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceAesEncryptArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "aesEncrypt", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceAesEncryptResult{}
  var retval []byte
  if retval, err2 = p.handler.AesEncrypt(ctx, args.Key, args.Raw); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aesEncrypt: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "aesEncrypt", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "aesEncrypt", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type tPKEServiceProcessorAesDecrypt struct {
  handler TPKEService
}

func (p *tPKEServiceProcessorAesDecrypt) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := TPKEServiceAesDecryptArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "aesDecrypt", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := TPKEServiceAesDecryptResult{}
  var retval []byte
  if retval, err2 = p.handler.AesDecrypt(ctx, args.Key, args.EncMes); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aesDecrypt: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "aesDecrypt", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "aesDecrypt", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - PubKey
//  - S
//  - J
type TPKEServiceLagrangeArgs struct {
  PubKey *TPKEPublicKeyThrift `thrift:"PubKey,1" db:"PubKey" json:"PubKey"`
  S []int32 `thrift:"S,2" db:"S" json:"S"`
  J int32 `thrift:"j,3" db:"j" json:"j"`
}

func NewTPKEServiceLagrangeArgs() *TPKEServiceLagrangeArgs {
  return &TPKEServiceLagrangeArgs{}
}

var TPKEServiceLagrangeArgs_PubKey_DEFAULT *TPKEPublicKeyThrift
func (p *TPKEServiceLagrangeArgs) GetPubKey() *TPKEPublicKeyThrift {
  if !p.IsSetPubKey() {
    return TPKEServiceLagrangeArgs_PubKey_DEFAULT
  }
return p.PubKey
}

func (p *TPKEServiceLagrangeArgs) GetS() []int32 {
  return p.S
}

func (p *TPKEServiceLagrangeArgs) GetJ() int32 {
  return p.J
}
func (p *TPKEServiceLagrangeArgs) IsSetPubKey() bool {
  return p.PubKey != nil
}

func (p *TPKEServiceLagrangeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceLagrangeArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PubKey = &TPKEPublicKeyThrift{}
  if err := p.PubKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PubKey), err)
  }
  return nil
}

func (p *TPKEServiceLagrangeArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]int32, 0, size)
  p.S =  tSet
  for i := 0; i < size; i ++ {
var _elem29 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem29 = v
}
    p.S = append(p.S, _elem29)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TPKEServiceLagrangeArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.J = v
}
  return nil
}

func (p *TPKEServiceLagrangeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "lagrange_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceLagrangeArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PubKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:PubKey: ", p), err) }
  if err := p.PubKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PubKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:PubKey: ", p), err) }
  return err
}

func (p *TPKEServiceLagrangeArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "S", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:S: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.S)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.S); i++ {
    for j := i+1; j<len(p.S); j++ {
      if func(tgt, src int32) bool {
        if tgt != src { return false }
        return true
      }(p.S[i], p.S[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.S))
      }
    }
  }
  for _, v := range p.S {
    if err := oprot.WriteI32(ctx, int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:S: ", p), err) }
  return err
}

func (p *TPKEServiceLagrangeArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "j", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:j: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.J)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.j (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:j: ", p), err) }
  return err
}

func (p *TPKEServiceLagrangeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceLagrangeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceLagrangeResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceLagrangeResult() *TPKEServiceLagrangeResult {
  return &TPKEServiceLagrangeResult{}
}

var TPKEServiceLagrangeResult_Success_DEFAULT int32
func (p *TPKEServiceLagrangeResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return TPKEServiceLagrangeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *TPKEServiceLagrangeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceLagrangeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceLagrangeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *TPKEServiceLagrangeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "lagrange_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceLagrangeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceLagrangeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceLagrangeResult(%+v)", *p)
}

// Attributes:
//  - PubKey
//  - M
type TPKEServiceEncryptArgs struct {
  PubKey *TPKEPublicKeyThrift `thrift:"PubKey,1" db:"PubKey" json:"PubKey"`
  M string `thrift:"m,2" db:"m" json:"m"`
}

func NewTPKEServiceEncryptArgs() *TPKEServiceEncryptArgs {
  return &TPKEServiceEncryptArgs{}
}

var TPKEServiceEncryptArgs_PubKey_DEFAULT *TPKEPublicKeyThrift
func (p *TPKEServiceEncryptArgs) GetPubKey() *TPKEPublicKeyThrift {
  if !p.IsSetPubKey() {
    return TPKEServiceEncryptArgs_PubKey_DEFAULT
  }
return p.PubKey
}

func (p *TPKEServiceEncryptArgs) GetM() string {
  return p.M
}
func (p *TPKEServiceEncryptArgs) IsSetPubKey() bool {
  return p.PubKey != nil
}

func (p *TPKEServiceEncryptArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceEncryptArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PubKey = &TPKEPublicKeyThrift{}
  if err := p.PubKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PubKey), err)
  }
  return nil
}

func (p *TPKEServiceEncryptArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.M = v
}
  return nil
}

func (p *TPKEServiceEncryptArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "encrypt_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceEncryptArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PubKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:PubKey: ", p), err) }
  if err := p.PubKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PubKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:PubKey: ", p), err) }
  return err
}

func (p *TPKEServiceEncryptArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "m", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:m: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.M)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.m (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:m: ", p), err) }
  return err
}

func (p *TPKEServiceEncryptArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceEncryptArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceEncryptResult struct {
  Success *EncryptedMessageThrift `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceEncryptResult() *TPKEServiceEncryptResult {
  return &TPKEServiceEncryptResult{}
}

var TPKEServiceEncryptResult_Success_DEFAULT *EncryptedMessageThrift
func (p *TPKEServiceEncryptResult) GetSuccess() *EncryptedMessageThrift {
  if !p.IsSetSuccess() {
    return TPKEServiceEncryptResult_Success_DEFAULT
  }
return p.Success
}
func (p *TPKEServiceEncryptResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceEncryptResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceEncryptResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &EncryptedMessageThrift{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *TPKEServiceEncryptResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "encrypt_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceEncryptResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceEncryptResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceEncryptResult(%+v)", *p)
}

// Attributes:
//  - PubKey
//  - Em
//  - Shares
type TPKEServiceCombineSharesArgs struct {
  PubKey *TPKEPublicKeyThrift `thrift:"PubKey,1" db:"PubKey" json:"PubKey"`
  Em *EncryptedMessageThrift `thrift:"em,2" db:"em" json:"em"`
  Shares map[int32][]byte `thrift:"shares,3" db:"shares" json:"shares"`
}

func NewTPKEServiceCombineSharesArgs() *TPKEServiceCombineSharesArgs {
  return &TPKEServiceCombineSharesArgs{}
}

var TPKEServiceCombineSharesArgs_PubKey_DEFAULT *TPKEPublicKeyThrift
func (p *TPKEServiceCombineSharesArgs) GetPubKey() *TPKEPublicKeyThrift {
  if !p.IsSetPubKey() {
    return TPKEServiceCombineSharesArgs_PubKey_DEFAULT
  }
return p.PubKey
}
var TPKEServiceCombineSharesArgs_Em_DEFAULT *EncryptedMessageThrift
func (p *TPKEServiceCombineSharesArgs) GetEm() *EncryptedMessageThrift {
  if !p.IsSetEm() {
    return TPKEServiceCombineSharesArgs_Em_DEFAULT
  }
return p.Em
}

func (p *TPKEServiceCombineSharesArgs) GetShares() map[int32][]byte {
  return p.Shares
}
func (p *TPKEServiceCombineSharesArgs) IsSetPubKey() bool {
  return p.PubKey != nil
}

func (p *TPKEServiceCombineSharesArgs) IsSetEm() bool {
  return p.Em != nil
}

func (p *TPKEServiceCombineSharesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceCombineSharesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PubKey = &TPKEPublicKeyThrift{}
  if err := p.PubKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PubKey), err)
  }
  return nil
}

func (p *TPKEServiceCombineSharesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Em = &EncryptedMessageThrift{}
  if err := p.Em.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Em), err)
  }
  return nil
}

func (p *TPKEServiceCombineSharesArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]byte, size)
  p.Shares =  tMap
  for i := 0; i < size; i ++ {
var _key30 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key30 = v
}
var _val31 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val31 = v
}
    p.Shares[_key30] = _val31
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TPKEServiceCombineSharesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "combineShares_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceCombineSharesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PubKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:PubKey: ", p), err) }
  if err := p.PubKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PubKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:PubKey: ", p), err) }
  return err
}

func (p *TPKEServiceCombineSharesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "em", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:em: ", p), err) }
  if err := p.Em.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Em), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:em: ", p), err) }
  return err
}

func (p *TPKEServiceCombineSharesArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "shares", thrift.MAP, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:shares: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.STRING, len(p.Shares)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Shares {
    if err := oprot.WriteI32(ctx, int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:shares: ", p), err) }
  return err
}

func (p *TPKEServiceCombineSharesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceCombineSharesArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceCombineSharesResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceCombineSharesResult() *TPKEServiceCombineSharesResult {
  return &TPKEServiceCombineSharesResult{}
}

var TPKEServiceCombineSharesResult_Success_DEFAULT []byte

func (p *TPKEServiceCombineSharesResult) GetSuccess() []byte {
  return p.Success
}
func (p *TPKEServiceCombineSharesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceCombineSharesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceCombineSharesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *TPKEServiceCombineSharesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "combineShares_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceCombineSharesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceCombineSharesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceCombineSharesResult(%+v)", *p)
}

// Attributes:
//  - PrivKey
//  - Em
type TPKEServiceDecryptShareArgs struct {
  PrivKey *TPKEPrivateKeyThrift `thrift:"PrivKey,1" db:"PrivKey" json:"PrivKey"`
  Em *EncryptedMessageThrift `thrift:"em,2" db:"em" json:"em"`
}

func NewTPKEServiceDecryptShareArgs() *TPKEServiceDecryptShareArgs {
  return &TPKEServiceDecryptShareArgs{}
}

var TPKEServiceDecryptShareArgs_PrivKey_DEFAULT *TPKEPrivateKeyThrift
func (p *TPKEServiceDecryptShareArgs) GetPrivKey() *TPKEPrivateKeyThrift {
  if !p.IsSetPrivKey() {
    return TPKEServiceDecryptShareArgs_PrivKey_DEFAULT
  }
return p.PrivKey
}
var TPKEServiceDecryptShareArgs_Em_DEFAULT *EncryptedMessageThrift
func (p *TPKEServiceDecryptShareArgs) GetEm() *EncryptedMessageThrift {
  if !p.IsSetEm() {
    return TPKEServiceDecryptShareArgs_Em_DEFAULT
  }
return p.Em
}
func (p *TPKEServiceDecryptShareArgs) IsSetPrivKey() bool {
  return p.PrivKey != nil
}

func (p *TPKEServiceDecryptShareArgs) IsSetEm() bool {
  return p.Em != nil
}

func (p *TPKEServiceDecryptShareArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceDecryptShareArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PrivKey = &TPKEPrivateKeyThrift{}
  if err := p.PrivKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PrivKey), err)
  }
  return nil
}

func (p *TPKEServiceDecryptShareArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Em = &EncryptedMessageThrift{}
  if err := p.Em.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Em), err)
  }
  return nil
}

func (p *TPKEServiceDecryptShareArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "decryptShare_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceDecryptShareArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "PrivKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:PrivKey: ", p), err) }
  if err := p.PrivKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PrivKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:PrivKey: ", p), err) }
  return err
}

func (p *TPKEServiceDecryptShareArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "em", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:em: ", p), err) }
  if err := p.Em.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Em), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:em: ", p), err) }
  return err
}

func (p *TPKEServiceDecryptShareArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceDecryptShareArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceDecryptShareResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceDecryptShareResult() *TPKEServiceDecryptShareResult {
  return &TPKEServiceDecryptShareResult{}
}

var TPKEServiceDecryptShareResult_Success_DEFAULT []byte

func (p *TPKEServiceDecryptShareResult) GetSuccess() []byte {
  return p.Success
}
func (p *TPKEServiceDecryptShareResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceDecryptShareResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceDecryptShareResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *TPKEServiceDecryptShareResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "decryptShare_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceDecryptShareResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceDecryptShareResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceDecryptShareResult(%+v)", *p)
}

// Attributes:
//  - Players
//  - K
type TPKEServiceDealerArgs struct {
  Players int32 `thrift:"players,1" db:"players" json:"players"`
  K int32 `thrift:"k,2" db:"k" json:"k"`
}

func NewTPKEServiceDealerArgs() *TPKEServiceDealerArgs {
  return &TPKEServiceDealerArgs{}
}


func (p *TPKEServiceDealerArgs) GetPlayers() int32 {
  return p.Players
}

func (p *TPKEServiceDealerArgs) GetK() int32 {
  return p.K
}
func (p *TPKEServiceDealerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceDealerArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Players = v
}
  return nil
}

func (p *TPKEServiceDealerArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.K = v
}
  return nil
}

func (p *TPKEServiceDealerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "dealer_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceDealerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "players", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:players: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Players)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.players (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:players: ", p), err) }
  return err
}

func (p *TPKEServiceDealerArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.K)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.k (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *TPKEServiceDealerArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceDealerArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceDealerResult struct {
  Success *DealerThrift `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceDealerResult() *TPKEServiceDealerResult {
  return &TPKEServiceDealerResult{}
}

var TPKEServiceDealerResult_Success_DEFAULT *DealerThrift
func (p *TPKEServiceDealerResult) GetSuccess() *DealerThrift {
  if !p.IsSetSuccess() {
    return TPKEServiceDealerResult_Success_DEFAULT
  }
return p.Success
}
func (p *TPKEServiceDealerResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceDealerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceDealerResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &DealerThrift{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *TPKEServiceDealerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "dealer_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceDealerResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceDealerResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceDealerResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - Raw
type TPKEServiceAesEncryptArgs struct {
  Key *AESKey `thrift:"key,1" db:"key" json:"key"`
  Raw []byte `thrift:"raw,2" db:"raw" json:"raw"`
}

func NewTPKEServiceAesEncryptArgs() *TPKEServiceAesEncryptArgs {
  return &TPKEServiceAesEncryptArgs{}
}

var TPKEServiceAesEncryptArgs_Key_DEFAULT *AESKey
func (p *TPKEServiceAesEncryptArgs) GetKey() *AESKey {
  if !p.IsSetKey() {
    return TPKEServiceAesEncryptArgs_Key_DEFAULT
  }
return p.Key
}

func (p *TPKEServiceAesEncryptArgs) GetRaw() []byte {
  return p.Raw
}
func (p *TPKEServiceAesEncryptArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *TPKEServiceAesEncryptArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceAesEncryptArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &AESKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *TPKEServiceAesEncryptArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Raw = v
}
  return nil
}

func (p *TPKEServiceAesEncryptArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aesEncrypt_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceAesEncryptArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *TPKEServiceAesEncryptArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "raw", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:raw: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Raw); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.raw (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:raw: ", p), err) }
  return err
}

func (p *TPKEServiceAesEncryptArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceAesEncryptArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceAesEncryptResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceAesEncryptResult() *TPKEServiceAesEncryptResult {
  return &TPKEServiceAesEncryptResult{}
}

var TPKEServiceAesEncryptResult_Success_DEFAULT []byte

func (p *TPKEServiceAesEncryptResult) GetSuccess() []byte {
  return p.Success
}
func (p *TPKEServiceAesEncryptResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceAesEncryptResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceAesEncryptResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *TPKEServiceAesEncryptResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aesEncrypt_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceAesEncryptResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceAesEncryptResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceAesEncryptResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - EncMes
type TPKEServiceAesDecryptArgs struct {
  Key *AESKey `thrift:"key,1" db:"key" json:"key"`
  EncMes []byte `thrift:"encMes,2" db:"encMes" json:"encMes"`
}

func NewTPKEServiceAesDecryptArgs() *TPKEServiceAesDecryptArgs {
  return &TPKEServiceAesDecryptArgs{}
}

var TPKEServiceAesDecryptArgs_Key_DEFAULT *AESKey
func (p *TPKEServiceAesDecryptArgs) GetKey() *AESKey {
  if !p.IsSetKey() {
    return TPKEServiceAesDecryptArgs_Key_DEFAULT
  }
return p.Key
}

func (p *TPKEServiceAesDecryptArgs) GetEncMes() []byte {
  return p.EncMes
}
func (p *TPKEServiceAesDecryptArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *TPKEServiceAesDecryptArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceAesDecryptArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &AESKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *TPKEServiceAesDecryptArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EncMes = v
}
  return nil
}

func (p *TPKEServiceAesDecryptArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aesDecrypt_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceAesDecryptArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *TPKEServiceAesDecryptArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "encMes", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:encMes: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.EncMes); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.encMes (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:encMes: ", p), err) }
  return err
}

func (p *TPKEServiceAesDecryptArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceAesDecryptArgs(%+v)", *p)
}

// Attributes:
//  - Success
type TPKEServiceAesDecryptResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTPKEServiceAesDecryptResult() *TPKEServiceAesDecryptResult {
  return &TPKEServiceAesDecryptResult{}
}

var TPKEServiceAesDecryptResult_Success_DEFAULT []byte

func (p *TPKEServiceAesDecryptResult) GetSuccess() []byte {
  return p.Success
}
func (p *TPKEServiceAesDecryptResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *TPKEServiceAesDecryptResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TPKEServiceAesDecryptResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *TPKEServiceAesDecryptResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aesDecrypt_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPKEServiceAesDecryptResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *TPKEServiceAesDecryptResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPKEServiceAesDecryptResult(%+v)", *p)
}


